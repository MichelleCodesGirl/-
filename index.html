<!DOCTYPE html>
<html>
<head>
    <title>Grapple-Bot: Infinite Trials</title>
    <style>
        body { margin: 0; overflow: hidden; background: #05050a; font-family: 'Courier New', monospace; }
        canvas { display: block; }
        #ui { position: absolute; top: 20px; left: 20px; color: #00fff2; pointer-events: none; }
        .stat { background: rgba(0, 255, 242, 0.1); padding: 10px; border: 1px solid #00fff2; margin-bottom: 5px; box-shadow: 0 0 10px #00fff2; }
        #level-tag { position: absolute; top: 20px; right: 20px; color: #ff0055; font-size: 24px; font-weight: bold; }
    </style>
</head>
<body>

<div id="ui">
    <div class="stat">SYSTEM: ACTIVE</div>
    <div class="stat">FAILURES: <span id="deaths">0</span></div>
</div>
<div id="level-tag">SECTOR: <span id="lvl">1</span></div>

<canvas id="game"></canvas>

<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

let deaths = 0;
let currentLevel = 1;
let sawAngle = 0;
let cameraX = 0;

const player = {
    x: 100, y: 300, w: 30, h: 30,
    vx: 0, vy: 0,
    speed: 0.6, drag: 0.98, gravity: 0.45,
    grapplePoint: null, isGrappling: false, length: 0
};

let platforms = [];
let saws = [];
let goal = { x: 3000, y: 0, w: 50, h: 1000 };

// --- Level Generator ---
function buildLevel(lvl) {
    player.x = 100; player.y = 300; player.vx = 0; player.vy = 0;
    cameraX = 0;
    platforms = [
        { x: 0, y: 500, w: 400, h: 100 }, // Start
    ];
    saws = [];
    
    // Create a long, hard track
    const levelLength = 2000 + (lvl * 1000);
    goal.x = levelLength;

    for (let i = 1; i < levelLength / 400; i++) {
        // Random Platforms
        platforms.push({
            x: i * 450,
            y: 300 + Math.random() * 250,
            w: 200 + Math.random() * 200,
            h: 40
        });
        
        // Harder Saws (More saws as level increases)
        for (let j = 0; j < lvl; j++) {
            saws.push({
                x: i * 450 + (Math.random() * 300),
                y: 100 + (Math.random() * 400),
                radius: 30 + (Math.random() * 20),
                speed: 0.05 + (lvl * 0.01)
            });
        }
    }
}

const keys = {};
window.onkeydown = (e) => keys[e.code] = true;
window.onkeyup = (e) => keys[e.code] = false;

window.onmousedown = (e) => {
    // Correct mouse click for camera position
    player.grapplePoint = { x: e.clientX + cameraX, y: e.clientY };
    const dx = (player.x + 15) - player.grapplePoint.x;
    const dy = (player.y + 15) - player.grapplePoint.y;
    player.length = Math.sqrt(dx*dx + dy*dy);
    player.isGrappling = true;
};
window.onmouseup = () => player.isGrappling = false;

function reset() {
    player.x = 100; player.y = 300;
    player.vx = 0; player.vy = 0;
    player.isGrappling = false;
    deaths++;
    document.getElementById('deaths').innerText = deaths;
}

function update() {
    if (keys['ArrowRight'] || keys['KeyD']) player.vx += player.speed;
    if (keys['ArrowLeft'] || keys['KeyA']) player.vx -= player.speed;
    
    player.vy += player.gravity;
    player.vx *= player.drag;

    if (player.isGrappling) {
        const dx = (player.x + 15) - player.grapplePoint.x;
        const dy = (player.y + 15) - player.grapplePoint.y;
        const dist = Math.sqrt(dx*dx + dy*dy);
        if (dist > player.length) {
            const angle = Math.atan2(dy, dx);
            player.x = (player.grapplePoint.x + Math.cos(angle) * player.length) - 15;
            player.y = (player.grapplePoint.y + Math.sin(angle) * player.length) - 15;
            const vDotR = (player.vx * dx + player.vy * dy) / dist;
            player.vx -= vDotR * (dx / dist);
            player.vy -= vDotR * (dy / dist);
        }
    }

    player.x += player.vx;
    player.y += player.vy;
    sawAngle += 0.15;

    // Camera follow
    cameraX += (player.x - cameraX - canvas.width / 3) * 0.1;

    // Collisions
    platforms.forEach(p => {
        if (player.x < p.x + p.w && player.x + player.w > p.x &&
            player.y < p.y + p.h && player.y + player.h > p.y) {
            if (player.vy > 0) { player.y = p.y - player.h; player.vy = 0; }
        }
    });

    saws.forEach(s => {
        const dx = (player.x + 15) - s.x;
        const dy = (player.y + 15) - s.y;
        if (Math.sqrt(dx*dx + dy*dy) < s.radius + 10) reset();
    });

    // Check Win (Goal)
    if (player.x > goal.x) {
        currentLevel++;
        document.getElementById('lvl').innerText = currentLevel;
        buildLevel(currentLevel);
    }

    if (player.y > canvas.height + 500) reset();
}

function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.save();
    ctx.translate(-cameraX, 0);

    // Draw Goal Gate
    ctx.fillStyle = '#00fff2';
    ctx.shadowBlur = 20;
    ctx.fillRect(goal.x, 0, 10, canvas.height);

    // Draw Saws
    saws.forEach(s => {
        ctx.save();
        ctx.translate(s.x, s.y);
        ctx.rotate(sawAngle);
        ctx.fillStyle = '#ff0055';
        ctx.shadowColor = '#ff0055';
        for(let i=0; i<8; i++) {
            ctx.rotate(Math.PI/4);
            ctx.fillRect(0, -s.radius, 6, s.radius*2);
        }
        ctx.restore();
    });

    // Draw Rope
    if (player.isGrappling) {
        ctx.strokeStyle = '#00fff2';
        ctx.beginPath();
        ctx.moveTo(player.x + 15, player.y + 15);
        ctx.lineTo(player.grapplePoint.x, player.grapplePoint.y);
        ctx.stroke();
    }

    // Draw Player
    ctx.fillStyle = '#00fff2';
    ctx.shadowColor = '#00fff2';
    ctx.fillRect(player.x, player.y, player.w, player.h);

    // Draw Ground
    ctx.shadowBlur = 0;
    ctx.fillStyle = '#111122';
    platforms.forEach(p => ctx.fillRect(p.x, p.y, p.w, p.h));

    ctx.restore();
}

buildLevel(1);
function loop() { update(); draw(); requestAnimationFrame(loop); }
loop();
</script>
</body>
</html>
